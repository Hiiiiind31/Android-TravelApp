package com.example.aqi.travelapp;

/**
 * Created by aqi on 3/11/15.
 */
import java.util.*;
import static com.example.aqi.travelapp.CostUtils.*;
//Static import to get all the static members of CostUtils to reduce verbosity

public class FastApproxSolver {

    /***************************************************************
     * Fast approximate solver uses 2-opt with a starting configuration
     * generated by nearest neighbour
     * *************************************************************/

    //Generates an itinerary (ArrayList<String>) based on nearest neighbour,
    //given an ArrayList<String> of destinations
    //The starting point will be the first element of the destinations ArrayList,
    //while the ending point will be the last
    public static ArrayList<String> planItineraryNN(ArrayList<String> destinations)
    {
        double timecost = 0;
        String nextdestination ="";
        int itinerarysize = destinations.get(0).equals(destinations.get(destinations.size()-1))?
                destinations.size()-1:destinations.size();
        ArrayList<String> itinerary = new ArrayList<String>();
        itinerary.add(destinations.remove(0));//add starting point

        while(itinerary.size()<itinerarysize)
        {
            timecost = TimeCostAve(itinerary.get(itinerary.size()-1), destinations.get(0));
            nextdestination = destinations.get(0);

            for(int i =0; i<destinations.size()-1;i++) //exclude the ending point
            {
                double newtimecost = TimeCostAve(itinerary.get(itinerary.size()-1), destinations.get(i));
                if(newtimecost < timecost)
                {
                    timecost = newtimecost;
                    nextdestination = destinations.get(i);

                }
            }

            itinerary.add(nextdestination);
            destinations.remove(nextdestination);
        }

        return itinerary;
    }

    //Swaps two nodes and returns the new itinerary
    public static ArrayList<String> swapNodes(ArrayList<String> itinerary, int node1, int node2)
    {
        if(node1==node2)
            return itinerary;

        //Since the swap assumes node1<node2
        if(node1>node2)
        {
            int temp = node1;
            node1 = node2;
            node2 = temp;
        }

        ArrayList<String> newitinerary = new ArrayList<String>();
        for(int i = 0; i<node1;i++)
            newitinerary.add(itinerary.get(i));
        for(int i = node2; i>=node1; i--)
            newitinerary.add(itinerary.get(i));
        for(int i = node2+1; i<itinerary.size();i++)
            newitinerary.add(itinerary.get(i));

        return newitinerary;

    }

    //Greedy 2-opt: given an itinerary, swaps nodes and checks for improvement,
    //If there is an improvement, swap the nodes immediately.
    //If not continue until no further improvement is possible
    public static ArrayList<String> getTwoOpt(ArrayList<String> itinerary)
    {
        ArrayList<String> newitinerary;
        double timecost = TotalTimeCostAve(itinerary);
        int i = 1;
        int j = 2;

        while(i<itinerary.size())
        {
            while(j<itinerary.size())
            {

                System.out.println("i and j "+ i + " "+ j);
                newitinerary = swapNodes(itinerary,i,j);
                double newtimecost = TotalTimeCostAve(newitinerary);
                System.out.println("New itinerary and cost: " + newitinerary);
                System.out.println("cost" + newtimecost);

                if(newtimecost < timecost)
                {
                    itinerary = newitinerary;

                    System.out.println("Assigning new itinerary: " + itinerary);
                    i = 1;
                    j = 2;
                }
                else
                {
                    j++;
                }

            }
            i++;
            j = i+1;
        }

        return itinerary;
    }
}

